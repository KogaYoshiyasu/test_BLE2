<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BLE RSSI & Image Route Sync</title>
  <style>
    body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background: #f0f2f5; margin: 0; padding: 20px; }
    .main-layout { display: flex; flex-direction: column; gap: 20px; width: 100%; max-width: 800px; }
    
    .card { background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .row { display: flex; gap: 10px; align-items: center; margin-top: 10px; flex-wrap: wrap; }
    
    /* 画像とピンのスタイル */
    .image-container { position: relative; width: 100%; background: #ddd; border-radius: 8px; overflow: hidden; line-height: 0; cursor: crosshair; }
    img { width: 100%; height: auto; display: block; }
    img[src=""] { display: none; }
    
    .point { position: absolute; width: 20px; height: 20px; border: 2px solid #fff; border-radius: 50%; transform: translate(-50%, -50%); display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold; color: white; background: #007bff; pointer-events: none; }
    .point.moving { background: #ff9500; width: 26px; height: 26px; z-index: 20; box-shadow: 0 0 12px rgba(255,149,0,0.9); }

    /* ステータス表示
    .status-box { background: #333; color: #fff; padding: 15px; border-radius: 8px; margin-bottom: 10px; }
    .status-box p { margin: 5px 0; font-family: monospace; } */
    
    /* 履歴リスト */
    .history-item { display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid #eee; }
    button { padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; color: white; }
    .btn-green { background: #28a745; } .btn-red { background: #dc3545; } .btn-blue { background: #007bff; } .btn-purple { background: #6f42c1; } .btn-gray { background: #6c757d; } .btn-orange { background: #fd7e14; }
    button:disabled { background: #ccc; }
  </style>
</head>
<body>

<div class="main-layout">
  <div class="card">
    <strong>地図の写真の読み込み</strong>
    <input type="file" id="fileInput" accept="image/*" style="margin-top:10px; display:block;">
    
    <div class="row">
      <button id="scan" class="btn-green">スキャン開始</button>
      <button id="stop" class="btn-red" disabled>停止・保存</button>
      <button id="guide" class="btn-blue" disabled>案内開始</button>
      <button id="guideStop" class="btn-red" disabled>案内停止</button>
      <button id="undoBtn" class="btn-orange" onclick="undoLastPoint()">1つ戻る</button>
      <button id="resetBtn" class="btn-gray" onclick="resetAll()">リセット</button>
    </div>
    <div class="row">
      <strong>ルート進行度</strong>
      <!-- <input type="range" id="range" min="0" max="1000" value="0" disabled style="flex-grow:1;"> -->
      <span id="pVal" style="font-weight:bold; width:50px;">0.0%</span>
      <span id="rssi" style="font-weight:bold; width:100px;">RSSI: --</span>
      <span id="avg" style="font-weight:bold; width:100px;">平均RSSI: --</span>
    </div>
  </div>

  <div class="image-container" id="container">
    <img id="img" src="">
  </div>

  <!-- <div class="status-box">
    <p id="rssi">RSSI: --</p>
    <p id="avg">平均RSSI: --</p>
    <p id="compare">ルート進捗: 未開始</p>
  </div> -->

  <div class="card">
    <strong>保存済みルート</strong>
    <div id="historyList"></div>
  </div>
</div>

<script>
  const BASE_URL = "https://test-server-757e.onrender.com";
  const maxSamples = 10;
  
  // ビーコン設定（実際のUUIDに書き換えてください）
  const BEACON_UUID_A = '12345678-1234-5678-1234-56789abcdef0';
  const BEACON_UUID_B = '12345678-1234-5678-1234-56789abcdef1';

  let points = []; 
  // ビーコンごとのデータを格納
  let rssiHistory = { a: [], b: [] };
  let routeData = []; // 保存形式: [{ a: -60, b: -80 }, ...]
  
  let scan, advertisementHandler;
  let isConfirmed = false;

  const container = document.getElementById('container');
  const img = document.getElementById('img');

  // --- BLEスキャン開始 ---
  async function startScan() {
    const options = { 
      filters: [
        { services: [BEACON_UUID_A] },
        { services: [BEACON_UUID_B] }
      ], 
      keepRepeatedDevices: true 
    };
    return await navigator.bluetooth.requestLEScan(options);
  }

  // --- RSSIハンドラー ---
  function createAdvertisementHandler(isTraining, callback) {
    return (event) => {
      const uuid = event.uuids[0];
      const rssi = event.rssi;
      if (rssi === undefined || rssi >= 0) return;

      const key = (uuid === BEACON_UUID_A) ? 'a' : 'b';
      rssiHistory[key].push(rssi);

      // 最新のRSSIを表示（UI更新）
      if(key === 'a') document.getElementById('rssi').innerText = `A: ${rssi}`;
      if(key === 'b') document.getElementById('avg').innerText = `B: ${rssi}`;

      // 両方のビーコンのサンプルが溜まったら平均を計算
      if (rssiHistory.a.length >= maxSamples && rssiHistory.b.length >= maxSamples) {
        const avgA = calculateAverage(rssiHistory.a.slice(-maxSamples));
        const avgB = calculateAverage(rssiHistory.b.slice(-maxSamples));
        
        // 配列をリセット（またはスライド）
        rssiHistory.a = [];
        rssiHistory.b = [];

        callback({ a: avgA, b: avgB });
      }
    };
  }

  function calculateAverage(array) {
    return array.reduce((sum, val) => sum + val, 0) / array.length;
  }

  // --- 案内ロジック (2つのRSSIで比較) ---
  function updateRouteGuide(currentAvgs, savedRoute) {
    let closestIndex = 0;
    let minDistance = Infinity;

    // 数学的な距離（ユークリッド距離）で最も近い記録地点を探す
    savedRoute.forEach((record, index) => {
      const dist = Math.sqrt(
        Math.pow(currentAvgs.a - record.a, 2) + 
        Math.pow(currentAvgs.b - record.b, 2)
      );
      if (dist < minDistance) {
        minDistance = dist;
        closestIndex = index;
      }
    });

    const percent = closestIndex / (savedRoute.length - 1);
    document.getElementById('pVal').innerText = (percent * 100).toFixed(1) + '%';
    updateMovingMarker(percent);
  }

  // --- ボタンアクション ---
  document.getElementById('scan').onclick = async () => {
    if (points.length < 2) return alert("ポイントを配置してください");
    
    scan = await startScan();
    isConfirmed = true;
    const trainingData = [];

    advertisementHandler = createAdvertisementHandler(true, (avgs) => {
      trainingData.push(avgs); // {a: -60, b: -75} の形式で保存
      console.log("Recorded:", avgs);
    });

    navigator.bluetooth.addEventListener('advertisementreceived', advertisementHandler);
    
    // UI制御
    setButtonsState(true);
    // 保存時に trainingData を routeData に代入する処理を stop 内に記述
    window.currentTrainingData = trainingData;
  };

  document.getElementById('stop').onclick = async () => {
    if (scan?.active) scan.stop();
    navigator.bluetooth.removeEventListener('advertisementreceived', advertisementHandler);

    const fd = new FormData();
    if (document.getElementById('fileInput').files[0]) {
      fd.append('image_file', document.getElementById('fileInput').files[0]);
    }
    fd.append('points_data', JSON.stringify(points));
    fd.append('route_data', JSON.stringify(window.currentTrainingData));

    try {
      const res = await fetch(`${BASE_URL}/upload`, { method: 'POST', body: fd });
      if(res.ok) { alert("2つのビーコンデータで保存しました"); loadHistory(); }
    } catch (e) { alert("送信エラー"); }
    
    setButtonsState(false);
  };

  document.getElementById('guide').onclick = async () => {
    if (!routeData.length) return alert("ルートデータがありません");
    scan = await startScan();
    
    advertisementHandler = createAdvertisementHandler(false, (avgs) => {
      updateRouteGuide(avgs, routeData);
    });

    navigator.bluetooth.addEventListener('advertisementreceived', advertisementHandler);
    document.getElementById('guide').disabled = true;
    document.getElementById('guideStop').disabled = false;
  };

  function setButtonsState(isScanning) {
    document.getElementById('scan').disabled = isScanning;
    document.getElementById('stop').disabled = !isScanning;
    document.getElementById('undoBtn').disabled = isScanning;
    document.getElementById('resetBtn').disabled = isScanning;
  }

  // --- 画像ルート操作 ---
  document.getElementById('fileInput').onchange = (e) => {
    resetCanvas();
    const reader = new FileReader();
    reader.onload = (ev) => { img.src = ev.target.result; };
    reader.readAsDataURL(e.target.files[0]);
  };

  container.onclick = (e) => {
    if (!img.src || isConfirmed) return;
    const rect = container.getBoundingClientRect();
    const x = (e.clientX - rect.left) / rect.width * 100;
    const y = (e.clientY - rect.top) / rect.height * 100;
    points.push({x, y});
    drawPointUI(x, y, points.length);
  };

  function drawPointUI(x, y, label) {
    const p = document.createElement('div');
    p.className = 'point';
    p.setAttribute('data-index', label);
    p.style.left = x+'%'; p.style.top = y+'%'; p.innerText = label;
    container.appendChild(p);
  }

  function undoLastPoint() {
    if (isConfirmed || points.length === 0) return;
    const lastPin = container.querySelector(`.point[data-index="${points.length}"]`);
    if (lastPin) lastPin.remove();
    points.pop();
  }

  // 修正かも
  function resetCanvas() {
    points = [];
    isConfirmed = false;
    img.onload = null;
    container.querySelectorAll('.point').forEach(p => p.remove());
    const m = document.getElementById('mov');
    if (m) m.remove();
    document.getElementById('pVal').innerText = '0.0%';
    document.getElementById('scan').disabled = false; 
    document.getElementById('stop').disabled = true;
    document.getElementById('guide').disabled = true; 
    document.getElementById('guideStop').disabled = true;
    document.getElementById('undoBtn').disabled = false; 
    document.getElementById('resetBtn').disabled = false;
  }

  // --- スライダーとマーカーの連動 ---
  // 修正（できたっぽい）
  function updateMovingMarker(percent) {
    let m = document.getElementById('mov');
    if (!m) {
      m = document.createElement('div');
      m.id = 'mov'; m.className = 'point moving';
      container.appendChild(m);
    }
    if (points.length < 2) return;

    const segs = points.length - 1;
    const i = Math.min(Math.floor(percent * segs), segs - 1);
    const p = (percent * segs) - i;
    
    const x = points[i].x + (points[i+1].x - points[i].x) * p;
    const y = points[i].y + (points[i+1].y - points[i].y) * p;
    
    m.style.left = x + '%';
    m.style.top = y + '%';
  }

  document.getElementById('guideStop').onclick = () => {
    if (scan?.active) scan.stop();
    if (advertisementHandler) {
      navigator.bluetooth.removeEventListener('advertisementreceived', advertisementHandler);
    }

    document.getElementById('guide').disabled = false; 
    document.getElementById('guideStop').disabled = true;
    document.getElementById('scan').disabled = true; 
    document.getElementById('stop').disabled = true;
    document.getElementById('undoBtn').disabled = true; 
    document.getElementById('resetBtn').disabled = false;
  };

  // 修正
  async function loadHistory() {
    try {
      const res = await fetch(`${BASE_URL}/list`);
      const data = await res.json();
      const list = document.getElementById('historyList');
      list.innerHTML = "";
      data.forEach(item => {
        const row = document.createElement('div');
        row.className = 'history-item';
        row.innerHTML = `
          <span>${item.name} (${item.points.length}点)</span>
          <div>
            <button class="btn-purple load-btn">読込</button>
            <button class="btn-red del-btn">削除</button>
          </div>`

        row.querySelector('.load-btn').onclick = () => applyHistory(item);
        row.querySelector('.del-btn').onclick = () => deleteHistory(item.id);

        list.appendChild(row);
      });
    } catch (e) { console.error("履歴取得失敗"); }
  }

  // 修正かも
  function applyHistory(item) {
    resetCanvas();
    img.onload = () => {
        points = item.points;
        points.forEach((p, i) => drawPointUI(p.x, p.y, i + 1));
        routeData = item.route;
        img.onload = null;
    };
    img.src = item.imageUrl;

    document.getElementById('scan').disabled = true; 
    document.getElementById('stop').disabled = true;
    document.getElementById('guide').disabled = false; 
    document.getElementById('guideStop').disabled = true;
    document.getElementById('undoBtn').disabled = true; 
    document.getElementById('resetBtn').disabled = false;
  }

  async function deleteHistory(id) {
    if (!confirm("削除しますか？")) return;
    try {
        const res = await fetch(`${BASE_URL}/history/${id}`, { method: 'DELETE' });
        if (res.ok) loadHistory();
    } catch (e) { alert("削除エラー"); }
  }

  function resetAll() { 
    resetCanvas(); 
    img.src = ""; 
    document.getElementById('fileInput').value = ""; 
  }

  loadHistory();
</script>
</body>
</html>
